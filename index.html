<script>
/* =========================================================
   Distribution Area & Critical Value Tool (Working Script)
   Matches IDs in your new <body>:
   dist, modeSelect, params_*, tail_area, tail_inv,
   x, a, b, p_in, calcArea, calcInv, warn, ok,
   outLabel, pout, interp, eq, x_block, ab_block,
   areaInputs, invInputs
========================================================= */

/* ---------- Core math utilities ---------- */

// Error function approximation (Abramowitz-Stegun 7.1.26)
function erf(x){
  const sign = x < 0 ? -1 : 1;
  x = Math.abs(x);
  const a1=0.254829592, a2=-0.284496736, a3=1.421413741, a4=-1.453152027, a5=1.061405429;
  const p=0.3275911;
  const t = 1.0/(1.0 + p*x);
  const y = 1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*Math.exp(-x*x);
  return sign*y;
}

function normalCDF(x, mu, sigma){
  const z = (x - mu) / (sigma * Math.SQRT2);
  return 0.5 * (1 + erf(z));
}

// Lanczos approximation for log-gamma
function gammaln(z){
  const p = [
    676.5203681218851,
   -1259.1392167224028,
    771.32342877765313,
   -176.61502916214059,
    12.507343278686905,
   -0.13857109526572012,
    9.9843695780195716e-6,
    1.5056327351493116e-7
  ];
  if (z < 0.5){
    return Math.log(Math.PI) - Math.log(Math.sin(Math.PI*z)) - gammaln(1 - z);
  }
  z -= 1;
  let x = 0.99999999999980993;
  for (let i=0; i<p.length; i++) x += p[i]/(z + i + 1);
  const t = z + p.length - 0.5;
  return 0.5*Math.log(2*Math.PI) + (z + 0.5)*Math.log(t) - t + Math.log(x);
}

// Regularized lower incomplete gamma P(a, x)
function gammaincLowerReg(a, x){
  if (x <= 0) return 0;
  if (a <= 0) return NaN;

  const ITMAX = 250;
  const EPS = 1e-14;
  const FPMIN = 1e-300;

  if (x < a + 1){
    let ap = a;
    let sum = 1/a;
    let del = sum;
    for (let n=1; n<=ITMAX; n++){
      ap += 1;
      del *= x/ap;
      sum += del;
      if (Math.abs(del) < Math.abs(sum)*EPS) break;
    }
    const result = sum * Math.exp(-x + a*Math.log(x) - gammaln(a));
    return Math.min(1, Math.max(0, result));
  } else {
    let b = x + 1 - a;
    let c = 1 / FPMIN;
    let d = 1 / b;
    let h = d;
    for (let i=1; i<=ITMAX; i++){
      const an = -i*(i - a);
      b += 2;
      d = an*d + b;
      if (Math.abs(d) < FPMIN) d = FPMIN;
      c = b + an/c;
      if (Math.abs(c) < FPMIN) c = FPMIN;
      d = 1/d;
      const del = d*c;
      h *= del;
      if (Math.abs(del - 1) < EPS) break;
    }
    const q = Math.exp(-x + a*Math.log(x) - gammaln(a)) * h;
    const p = 1 - q;
    return Math.min(1, Math.max(0, p));
  }
}

function gammaCDF(x, alpha, theta){
  if (x <= 0) return 0;
  if (alpha <= 0 || theta <= 0) return NaN;
  return gammaincLowerReg(alpha, x/theta);
}

function chisqCDF(x, nu){
  if (x <= 0) return 0;
  if (nu <= 0) return NaN;
  return gammaCDF(x, nu/2, 2);
}

function expCDF(x, lambda){
  if (x <= 0) return 0;
  if (lambda <= 0) return NaN;
  return 1 - Math.exp(-lambda*x);
}

function clamp01(p){
  if (!isFinite(p)) return NaN;
  return Math.min(1, Math.max(0, p));
}

function fmt(x){
  if (!isFinite(x)) return "—";
  const s = x.toFixed(10);
  return s.replace(/\.?0+$/, "");
}

/* ---------- Inverse solver (bisection with auto-bracket) ---------- */

function bisectSolve(F, target, lo, hi, tol=1e-10, maxIter=200){
  let flo = F(lo) - target;
  let fhi = F(hi) - target;

  if (!isFinite(flo) || !isFinite(fhi)) return {x: NaN, err:"Non-finite function values in solver interval."};
  if (flo === 0) return {x: lo};
  if (fhi === 0) return {x: hi};
  if (flo*fhi > 0) return {x: NaN, err:"Root is not bracketed."};

  for (let i=0; i<maxIter; i++){
    const mid = 0.5*(lo+hi);
    const fmid = F(mid) - target;
    if (!isFinite(fmid)) return {x: NaN, err:"Non-finite function value during solve."};
    if (Math.abs(fmid) < tol || (hi-lo)/2 < tol) return {x: mid};
    if (flo*fmid <= 0){
      hi = mid; fhi = fmid;
    } else {
      lo = mid; flo = fmid;
    }
  }
  return {x: 0.5*(lo+hi), warn:"Max iterations reached; returning best estimate."};
}

function invertMonotoneCDF(F, target, support){
  if (!(target >= 0 && target <= 1) || !isFinite(target)){
    return {x: NaN, err:"Target probability must be between 0 and 1."};
  }
  if (target === 0) return {x: support.min};
  if (target === 1) return {x: support.max};

  let lo = support.min;
  let hi = Math.max(support.start, lo);

  // push hi up until F(hi) >= target
  let fhi = F(hi);
  let step = support.step;
  for (let k=0; k<120 && fhi < target; k++){
    if (hi >= support.max) break;
    hi = Math.min(support.max, hi + step);
    fhi = F(hi);
    step *= support.grow;
  }

  const flo = F(lo);
  if (!(flo <= target && target <= fhi)){
    return {x: NaN, err:`Could not bracket target.\nF(lo)=${flo}, F(hi)=${fhi}`};
  }

  return bisectSolve(F, target, lo, hi);
}

/* ---------- DOM helpers ---------- */

const el = (id) => document.getElementById(id);

function clearMessages(){
  el("warn").textContent = "";
  el("ok").textContent = "";
}

function warn(msg){
  el("warn").textContent = msg;
  el("ok").textContent = "";
}

function ok(msg){
  el("ok").textContent = msg;
  el("warn").textContent = "";
}

/* ---------- Distribution CDF + support (for inverse) ---------- */

function getCDFAndSupport(){
  const d = el("dist").value;

  if (d === "normal"){
    const mu = Number(el("mu").value);
    const sigma = Number(el("sigma").value);
    if (!(sigma > 0)) return {err:"For Normal, σ must be > 0."};

    return {
      F: (x) => normalCDF(x, mu, sigma),
      desc: `Normal(μ=${mu}, σ=${sigma})`,
      support: { min: mu - 12*sigma, start: mu, step: 1*sigma, grow: 1.8, max: mu + 12*sigma }
    };
  }

  if (d === "gamma"){
    const alpha = Number(el("alpha").value);
    const theta = Number(el("theta").value);
    if (!(alpha > 0 && theta > 0)) return {err:"For Gamma, α and θ must be > 0."};

    const mean = alpha*theta;
    const sd = Math.sqrt(alpha)*theta;

    return {
      F: (x) => gammaCDF(x, alpha, theta),
      desc: `Gamma(α=${alpha}, θ=${theta})`,
      support: { min: 0, start: Math.max(0, mean), step: Math.max(1e-6, sd/2), grow: 1.8, max: mean + 50*sd + 10 }
    };
  }

  if (d === "chisq"){
    const nu = Number(el("nu").value);
    if (!(nu > 0)) return {err:"For Chi-square, ν must be > 0."};

    const mean = nu;
    const sd = Math.sqrt(2*nu);

    return {
      F: (x) => chisqCDF(x, nu),
      desc: `Chi-square(ν=${nu})`,
      support: { min: 0, start: Math.max(0, mean), step: Math.max(1e-6, sd/2), grow: 1.8, max: mean + 50*sd + 10 }
    };
  }

  if (d === "exp"){
    const lambda = Number(el("lambda").value);
    if (!(lambda > 0)) return {err:"For Exponential, λ must be > 0."};

    const mean = 1/lambda;
    const sd = 1/lambda;

    return {
      F: (x) => expCDF(x, lambda),
      desc: `Exponential(λ=${lambda})`,
      support: { min: 0, start: mean, step: Math.max(1e-6, sd/2), grow: 1.8, max: mean + 80*sd + 10 }
    };
  }

  return {err:"Unknown distribution selection."};
}

/* ---------- UI toggles ---------- */

function updateParamVisibility(){
  const d = el("dist").value;
  el("params_normal").style.display = (d==="normal") ? "" : "none";
  el("params_gamma").style.display  = (d==="gamma")  ? "" : "none";
  el("params_chisq").style.display  = (d==="chisq")  ? "" : "none";
  el("params_exp").style.display    = (d==="exp")    ? "" : "none";
}

function updateModeVisibility(){
  const mode = el("modeSelect").value;
  el("areaInputs").style.display = (mode === "area") ? "" : "none";
  el("invInputs").style.display  = (mode === "inv")  ? "" : "none";

  // clear output label appropriately
  el("outLabel").textContent = (mode === "area") ? "Probability" : "Critical value";
}

function updateAreaInputVisibility(){
  const t = el("tail_area").value;
  el("x_block").style.display  = (t === "btw") ? "none" : "";
  el("ab_block").style.display = (t === "btw") ? "" : "none";
}

/* ---------- Calculations ---------- */

function computeArea(){
  clearMessages();

  const pack = getCDFAndSupport();
  if (pack.err){ warn(pack.err); return; }

  const F = pack.F;
  const distDesc = pack.desc;

  const t = el("tail_area").value;

  let prob, eq, interp;

  if (t === "lt"){
    const x = Number(el("x").value);
    const Fx = clamp01(F(x));
    prob = Fx;
    interp = `P(X < ${x}) for ${distDesc}`;
    eq = `P(X < x) = F(x)\nF(${x}) = ${prob}`;
  }
  else if (t === "gt"){
    const x = Number(el("x").value);
    const Fx = clamp01(F(x));
    prob = clamp01(1 - Fx);
    interp = `P(X > ${x}) for ${distDesc}`;
    eq = `P(X > x) = 1 - F(x)\n1 - F(${x}) = ${prob}`;
  }
  else { // between
    const a = Number(el("a").value);
    const b = Number(el("b").value);
    const lo = Math.min(a,b);
    const hi = Math.max(a,b);

    const Flo = clamp01(F(lo));
    const Fhi = clamp01(F(hi));

    prob = clamp01(Fhi - Flo);
    interp = `P(${lo} < X < ${hi}) for ${distDesc}`;
    eq = `P(a < X < b) = F(b) - F(a)\nF(${hi}) - F(${lo}) = ${prob}`;
  }

  el("outLabel").textContent = "Probability";
  el("pout").textContent = fmt(prob);
  el("interp").textContent = interp;
  el("eq").textContent = eq;

  ok("Computed successfully.");
}

function computeInverse(){
  clearMessages();

  const pack = getCDFAndSupport();
  if (pack.err){ warn(pack.err); return; }

  const F = pack.F;
  const sup = pack.support;
  const distDesc = pack.desc;

  const p = Number(el("p_in").value);
  if (!(p >= 0 && p <= 1) || !isFinite(p)){
    warn("p must be a finite number between 0 and 1.");
    return;
  }

  const t = el("tail_inv").value;

  if (t === "lt"){
    const sol = invertMonotoneCDF(F, p, sup);
    if (sol.err){ warn(sol.err); return; }

    el("outLabel").textContent = "Critical value x";
    el("pout").textContent = fmt(sol.x);
    el("interp").textContent = `Find x such that P(X < x) = ${fmt(p)} for ${distDesc}`;
    el("eq").textContent = `Solve F(x)=p\np=${p}\nx=${sol.x}`;

    if (sol.warn) ok("Computed (with warning): " + sol.warn);
    else ok("Computed successfully.");
  }
  else if (t === "gt"){
    const target = 1 - p; // F(x)=1-p
    const sol = invertMonotoneCDF(F, target, sup);
    if (sol.err){ warn(sol.err); return; }

    el("outLabel").textContent = "Critical value x";
    el("pout").textContent = fmt(sol.x);
    el("interp").textContent = `Find x such that P(X > x) = ${fmt(p)} for ${distDesc}`;
    el("eq").textContent = `Solve 1-F(x)=p  ⇒  F(x)=1-p\n1-p=${target}\nx=${sol.x}`;

    if (sol.warn) ok("Computed (with warning): " + sol.warn);
    else ok("Computed successfully.");
  }
  else { // central interval
    const tail = (1 - p) / 2;
    const pL = tail;
    const pU = 1 - tail;

    const solL = invertMonotoneCDF(F, pL, sup);
    const solU = invertMonotoneCDF(F, pU, sup);
    if (solL.err){ warn("Lower bound failed:\n" + solL.err); return; }
    if (solU.err){ warn("Upper bound failed:\n" + solU.err); return; }

    el("outLabel").textContent = "Central interval [L, U]";
    el("pout").textContent = `[${fmt(solL.x)}, ${fmt(solU.x)}]`;
    el("interp").textContent = `Find L,U such that P(L < X < U) = ${fmt(p)} (equal tails) for ${distDesc}`;
    el("eq").textContent = `L = F^{-1}((1-p)/2), U = F^{-1}(1-(1-p)/2)\n(1-p)/2=${tail}\nL=${solL.x}\nU=${solU.x}`;

    ok("Computed successfully.");
  }
}

/* ---------- Wire up events ---------- */

function init(){
  updateParamVisibility();
  updateModeVisibility();
  updateAreaInputVisibility();

  el("dist").addEventListener("change", () => {
    updateParamVisibility();
    clearMessages();
  });

  el("modeSelect").addEventListener("change", () => {
    updateModeVisibility();
    clearMessages();
  });

  el("tail_area").addEventListener("change", () => {
    updateAreaInputVisibility();
    clearMessages();
  });

  el("calcArea").addEventListener("click", computeArea);
  el("calcInv").addEventListener("click", computeInverse);

  // initial output
  el("pout").textContent = "—";
  el("interp").textContent = "Choose a mode and inputs, then compute.";
  el("eq").textContent = "—";
}

init();
</script>
</body>
</html>
