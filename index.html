<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Distribution Area & Critical Value Tool</title>
 <style>
  :root{
    --erau-navy:#002855;
    --erau-gold:#F6BE00;
    --bg:#f4f6f9;
    --card:#ffffff;
    --text:#0f172a;
    --muted:#64748b;
    --line:rgba(15,23,42,.12);
    --radius:18px;
    --shadow:0 10px 25px rgba(0,0,0,.08);
    --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
    --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
  }

  body{
    margin:0;
    font-family:var(--sans);
    background:var(--bg);
    color:var(--text);
  }

  /* ================= HEADER ================= */

  .topbar{
    background:var(--erau-navy);
    color:white;
    padding:22px 32px 18px 32px;
    display:flex;
    justify-content:space-between;
    align-items:center;
  }

  .topbar-left h1{
    margin:0;
    font-size:22px;
    font-weight:700;
    letter-spacing:.2px;
  }

  .topbar-left p{
    margin:4px 0 0 0;
    font-size:14px;
    opacity:.85;
  }

  .erau-pill{
    background:var(--erau-gold);
    color:var(--erau-navy);
    padding:10px 22px;
    border-radius:999px;
    font-weight:700;
    font-size:14px;
    white-space:nowrap;
  }

  .gold-divider{
    height:4px;
    background:var(--erau-gold);
  }

  /* ================= CONTENT ================= */

  .wrapper{
    max-width:1200px;
    margin:28px auto;
    padding:0 20px;
  }

  .grid{
    display:grid;
    grid-template-columns:1fr 1.3fr;
    gap:24px;
  }

  @media(max-width:1000px){
    .grid{
      grid-template-columns:1fr;
    }
  }

  .card{
    background:var(--card);
    border-radius:var(--radius);
    box-shadow:var(--shadow);
    padding:22px;
    border:1px solid var(--line);
  }

  .card h2{
    margin:0 0 14px 0;
    font-size:16px;
    font-weight:700;
  }

  button{
    background:#2563eb;
    border:none;
    color:white;
    padding:10px 18px;
    border-radius:12px;
    font-weight:600;
    cursor:pointer;
  }

  button:hover{
    opacity:.9;
  }
</style>

</head>
<body>

<!-- ================= HEADER ================= -->

<div class="topbar">
  <div class="topbar-left">
    <h1>Distribution Area & Critical Value Calculator</h1>
    <p>Normal • Gamma • Chi-Square • Exponential</p>
  </div>
  <div class="erau-pill">
    Embry-Riddle Aeronautical University
  </div>
</div>

<div class="gold-divider"></div>

<!-- ================= MAIN CONTENT ================= -->

<div class="wrapper">
  <div class="grid">

    <!-- ================= INPUT CARD ================= -->
    <div class="card">
      <h2>Input</h2>

      <!-- Distribution -->
      <label>Distribution</label>
      <select id="dist">
        <option value="normal">Normal (μ, σ)</option>
        <option value="gamma">Gamma (shape α, scale θ)</option>
        <option value="chisq">Chi-square (df ν)</option>
        <option value="exp">Exponential (rate λ)</option>
      </select>

      <br><br>

      <!-- Area / Inverse Mode -->
      <label>Mode</label>
      <select id="modeSelect">
        <option value="area">Area / Probability</option>
        <option value="inv">Inverse / Critical Value</option>
      </select>

      <br><br>

      <!-- Parameters -->
      <div id="params_normal">
        <label>Mean μ</label>
        <input id="mu" type="number" value="0">

        <label>Std Dev σ</label>
        <input id="sigma" type="number" value="1">
      </div>

      <div id="params_gamma" style="display:none;">
        <label>Shape α</label>
        <input id="alpha" type="number" value="2">

        <label>Scale θ</label>
        <input id="theta" type="number" value="2">
      </div>

      <div id="params_chisq" style="display:none;">
        <label>Degrees of Freedom ν</label>
        <input id="nu" type="number" value="4">
      </div>

      <div id="params_exp" style="display:none;">
        <label>Rate λ</label>
        <input id="lambda" type="number" value="1">
      </div>

      <br>

      <!-- Area Inputs -->
      <div id="areaInputs">
        <label>Probability Type</label>
        <select id="tail_area">
          <option value="lt">P(X &lt; x)</option>
          <option value="gt">P(X &gt; x)</option>
          <option value="btw">P(a &lt; X &lt; b)</option>
        </select>

        <br><br>

        <div id="x_block">
          <label>x</label>
          <input id="x" type="number" value="1.5">
        </div>

        <div id="ab_block" style="display:none;">
          <label>a</label>
          <input id="a" type="number" value="1">

          <label>b</label>
          <input id="b" type="number" value="3">
        </div>

        <br>
        <button id="calcArea">Compute Probability</button>
      </div>

      <!-- Inverse Inputs -->
      <div id="invInputs" style="display:none;">
        <label>p (between 0 and 1)</label>
        <input id="p_in" type="number" value="0.95">

        <br><br>

        <label>Critical Value Type</label>
        <select id="tail_inv">
          <option value="lt">Find x where P(X &lt; x) = p</option>
          <option value="gt">Find x where P(X &gt; x) = p</option>
          <option value="btw">Find central interval</option>
        </select>

        <br><br>

        <button id="calcInv">Compute Critical Value</button>
      </div>

    </div>

    <!-- ================= RESULTS CARD ================= -->
    <div class="card">
      <h2>Results</h2>

      <div id="warn" style="color:#b91c1c;"></div>
      <div id="ok" style="color:#0f766e;"></div>

      <br>

      <div>
        <strong id="outLabel">Probability</strong>
        <div id="pout" style="font-family:monospace;font-size:18px;">—</div>
      </div>

      <br>

      <div>
        <strong>Interpretation</strong>
        <div id="interp"></div>
      </div>

      <br>

      <div>
        <strong>Computation</strong>
        <div id="eq" style="font-family:monospace;"></div>
      </div>

    </div>

  </div>
</div>

<!-- KEEP YOUR EXISTING SCRIPT EXACTLY BELOW THIS LINE -->
<script>
  /* DO NOT MODIFY YOUR EXISTING JAVASCRIPT */
</script>

</body>


<script>
/* -----------------------------
   Core math utilities
------------------------------*/

// Error function approximation (Abramowitz-Stegun 7.1.26)
function erf(x){
  const sign = x < 0 ? -1 : 1;
  x = Math.abs(x);
  const a1=0.254829592, a2=-0.284496736, a3=1.421413741, a4=-1.453152027, a5=1.061405429;
  const p=0.3275911;
  const t = 1.0/(1.0 + p*x);
  const y = 1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*Math.exp(-x*x);
  return sign*y;
}

function normalCDF(x, mu, sigma){
  const z = (x - mu) / (sigma * Math.SQRT2);
  return 0.5 * (1 + erf(z));
}

// Lanczos approximation for log-gamma
function gammaln(z){
  const p = [
    676.5203681218851,
   -1259.1392167224028,
    771.32342877765313,
   -176.61502916214059,
    12.507343278686905,
   -0.13857109526572012,
    9.9843695780195716e-6,
    1.5056327351493116e-7
  ];
  if (z < 0.5){
    return Math.log(Math.PI) - Math.log(Math.sin(Math.PI*z)) - gammaln(1 - z);
  }
  z -= 1;
  let x = 0.99999999999980993;
  for (let i=0; i<p.length; i++) x += p[i]/(z + i + 1);
  const t = z + p.length - 0.5;
  return 0.5*Math.log(2*Math.PI) + (z + 0.5)*Math.log(t) - t + Math.log(x);
}

// Regularized lower incomplete gamma P(a, x)
function gammaincLowerReg(a, x){
  if (x <= 0) return 0;
  if (a <= 0) return NaN;

  const ITMAX = 250;
  const EPS = 1e-14;
  const FPMIN = 1e-300;

  if (x < a + 1){
    let ap = a;
    let sum = 1/a;
    let del = sum;
    for (let n=1; n<=ITMAX; n++){
      ap += 1;
      del *= x/ap;
      sum += del;
      if (Math.abs(del) < Math.abs(sum)*EPS) break;
    }
    const result = sum * Math.exp(-x + a*Math.log(x) - gammaln(a));
    return Math.min(1, Math.max(0, result));
  } else {
    let b = x + 1 - a;
    let c = 1 / FPMIN;
    let d = 1 / b;
    let h = d;
    for (let i=1; i<=ITMAX; i++){
      const an = -i*(i - a);
      b += 2;
      d = an*d + b;
      if (Math.abs(d) < FPMIN) d = FPMIN;
      c = b + an/c;
      if (Math.abs(c) < FPMIN) c = FPMIN;
      d = 1/d;
      const del = d*c;
      h *= del;
      if (Math.abs(del - 1) < EPS) break;
    }
    const q = Math.exp(-x + a*Math.log(x) - gammaln(a)) * h;
    const p = 1 - q;
    return Math.min(1, Math.max(0, p));
  }
}

function gammaCDF(x, alpha, theta){
  if (x <= 0) return 0;
  if (alpha <= 0 || theta <= 0) return NaN;
  return gammaincLowerReg(alpha, x/theta);
}

function chisqCDF(x, nu){
  if (x <= 0) return 0;
  if (nu <= 0) return NaN;
  return gammaCDF(x, nu/2, 2);
}

function expCDF(x, lambda){
  if (x <= 0) return 0;
  if (lambda <= 0) return NaN;
  return 1 - Math.exp(-lambda*x);
}

function clamp01(p){
  if (!isFinite(p)) return NaN;
  return Math.min(1, Math.max(0, p));
}

function fmt(x){
  if (!isFinite(x)) return "—";
  const s = x.toFixed(10);
  return s.replace(/\.?0+$/, "");
}

/* -----------------------------
   Inverse / root finding
------------------------------*/

// Bisection solver for F(x)=target on [lo,hi]
function bisectSolve(F, target, lo, hi, tol=1e-10, maxIter=200){
  let flo = F(lo) - target;
  let fhi = F(hi) - target;

  if (!isFinite(flo) || !isFinite(fhi)) return {x: NaN, err:"Non-finite function values in solver interval."};
  if (flo === 0) return {x: lo};
  if (fhi === 0) return {x: hi};
  if (flo*fhi > 0) return {x: NaN, err:"Root is not bracketed."};

  for (let i=0; i<maxIter; i++){
    const mid = 0.5*(lo+hi);
    const fmid = F(mid) - target;
    if (!isFinite(fmid)) return {x: NaN, err:"Non-finite function value during solve."};
    if (Math.abs(fmid) < tol || (hi-lo)/2 < tol) return {x: mid};
    if (flo*fmid <= 0){
      hi = mid; fhi = fmid;
    } else {
      lo = mid; flo = fmid;
    }
  }
  return {x: 0.5*(lo+hi), warn:"Max iterations reached; returning best estimate."};
}

// Automatic bracketing for monotone CDFs
function invertMonotoneCDF(F, target, support){
  // support: {min, start, step, grow, max} (start is an initial guess)
  const tol = 1e-10;
  const maxIter = 200;

  if (!(target > 0) && target !== 0) return {x: NaN, err:"target must be in [0,1]."};
  if (!(target < 1) && target !== 1) return {x: NaN, err:"target must be in [0,1]."};

  // Handle edges
  if (target === 0) return {x: support.min};
  if (target === 1) return {x: support.max};

  // Find lo,hi s.t. F(lo) <= target <= F(hi)
  let lo = support.min;
  let hi = support.start;

  // Ensure hi is at least min
  if (hi < lo) hi = lo;

  let flo = F(lo);
  let fhi = F(hi);

  // If already above target, move hi down? (rare with start near min)
  if (fhi < target){
    let step = support.step;
    for (let k=0; k<120; k++){
      if (hi >= support.max) break;
      hi = Math.min(support.max, hi + step);
      fhi = F(hi);
      if (fhi >= target) break;
      step *= support.grow;
    }
  } else if (flo > target){
    // Move lo down (for normal which has -inf support approximated by min)
    let step = support.step;
    for (let k=0; k<120; k++){
      if (lo <= support.min) break;
      lo = Math.max(support.min, lo - step);
      flo = F(lo);
      if (flo <= target) break;
      step *= support.grow;
    }
  }

  flo = F(lo);
  fhi = F(hi);

  if (!(flo <= target && target <= fhi)){
    return {x: NaN, err:`Could not bracket target. Try different parameters.\nF(lo)=${flo}, F(hi)=${fhi}`};
  }

  // Solve
  const sol = bisectSolve(F, target, lo, hi, tol, maxIter);
  return sol;
}

/* -----------------------------
   UI logic
------------------------------*/

const distEl = document.getElementById("dist");

const tabArea = document.getElementById("tabArea");
const tabInv = document.getElementById("tabInv");

const areaModeBlock = document.getElementById("areaModeBlock");
const invModeBlock = document.getElementById("invModeBlock");

const tailAreaEl = document.getElementById("tail_area");
const tailInvEl  = document.getElementById("tail_inv");

const paramsNormal = document.getElementById("params_normal");
const paramsGamma  = document.getElementById("params_gamma");
const paramsChisq  = document.getElementById("params_chisq");
const paramsExp    = document.getElementById("params_exp");

const areaInputs = document.getElementById("areaInputs");
const invInputs  = document.getElementById("invInputs");

const xBlock  = document.getElementById("x_block");
const abBlock = document.getElementById("ab_block");

const invCentralHelp = document.getElementById("invCentralHelp");

const warnEl = document.getElementById("warn");
const okEl   = document.getElementById("ok");

const poutEl = document.getElementById("pout");
const outLabelEl = document.getElementById("outLabel");
const interpEl = document.getElementById("interp");
const eqEl = document.getElementById("eq");

let mode = "area"; // "area" or "inv"

function showMessage(type, text){
  warnEl.style.display = "none";
  okEl.style.display = "none";
  if (!text) return;
  if (type === "warn"){
    warnEl.textContent = text;
    warnEl.style.display = "block";
  } else {
    okEl.textContent = text;
    okEl.style.display = "block";
  }
}

function updateDistVisibility(){
  const d = distEl.value;
  paramsNormal.style.display = (d==="normal") ? "" : "none";
  paramsGamma.style.display  = (d==="gamma")  ? "" : "none";
  paramsChisq.style.display  = (d==="chisq")  ? "" : "none";
  paramsExp.style.display    = (d==="exp")    ? "" : "none";
  showMessage("", "");
}

function updateAreaTailVisibility(){
  const t = tailAreaEl.value;
  xBlock.style.display  = (t==="btw") ? "none" : "";
  abBlock.style.display = (t==="btw") ? "" : "none";
}

function updateInvHelp(){
  invCentralHelp.style.display = (tailInvEl.value === "btw") ? "" : "none";
}

function setMode(newMode){
  mode = newMode;
  const isArea = mode === "area";

  tabArea.classList.toggle("active", isArea);
  tabInv.classList.toggle("active", !isArea);

  areaModeBlock.style.display = isArea ? "" : "none";
  invModeBlock.style.display  = isArea ? "none" : "";

  areaInputs.style.display = isArea ? "" : "none";
  invInputs.style.display  = isArea ? "none" : "";

  outLabelEl.textContent = isArea ? "Probability" : "Critical value";
  poutEl.textContent = "—";
  interpEl.textContent = "Choose a mode and inputs, then compute.";
  eqEl.textContent = "—";
  showMessage("", "");

  // ensure sub-visibility
  updateAreaTailVisibility();
  updateInvHelp();
  updateDistVisibility();
}

tabArea.addEventListener("click", () => setMode("area"));
tabInv.addEventListener("click", () => setMode("inv"));

distEl.addEventListener("change", updateDistVisibility);
tailAreaEl.addEventListener("change", updateAreaTailVisibility);
tailInvEl.addEventListener("change", updateInvHelp);

document.getElementById("swap").addEventListener("click", () => {
  const a = document.getElementById("a");
  const b = document.getElementById("b");
  const tmp = a.value;
  a.value = b.value;
  b.value = tmp;
});

function doReset(){
  distEl.value = "normal";
  tailAreaEl.value = "lt";
  tailInvEl.value = "lt";

  document.getElementById("mu").value = 0;
  document.getElementById("sigma").value = 1;

  document.getElementById("alpha").value = 2;
  document.getElementById("theta").value = 2;

  document.getElementById("nu").value = 4;

  document.getElementById("lambda").value = 1;

  document.getElementById("x").value = 1.5;
  document.getElementById("a").value = 1;
  document.getElementById("b").value = 3;

  document.getElementById("p_in").value = 0.95;

  poutEl.textContent = "—";
  interpEl.textContent = "Choose a mode and inputs, then compute.";
  eqEl.textContent = "—";
  showMessage("", "");

  updateDistVisibility();
  updateAreaTailVisibility();
  updateInvHelp();
}

document.getElementById("reset").addEventListener("click", () => doReset());
document.getElementById("reset2").addEventListener("click", () => doReset());

function getCDF(d){
  if (d==="normal"){
    const mu = Number(document.getElementById("mu").value);
    const sigma = Number(document.getElementById("sigma").value);
    if (!(sigma > 0)) return {F: null, err: "For Normal, σ must be > 0."};
    return {
      F: (x) => normalCDF(x, mu, sigma),
      eq: `Normal CDF Φ((x-μ)/σ) with μ=${mu}, σ=${sigma}`,
      support: { min: mu - 12*sigma, start: mu, step: 1*sigma, grow: 1.8, max: mu + 12*sigma }
    };
  }
  if (d==="gamma"){
    const alpha = Number(document.getElementById("alpha").value);
    const theta = Number(document.getElementById("theta").value);
    if (!(alpha > 0) || !(theta > 0)) return {F: null, err: "For Gamma, α and θ must be > 0."};
    // heuristic upper max: mean+15 sd (sd = sqrt(alpha)*theta)
    const mean = alpha*theta;
    const sd = Math.sqrt(alpha)*theta;
    return {
      F: (x) => gammaCDF(x, alpha, theta),
      eq: `Gamma CDF P(α, x/θ) with α=${alpha}, θ=${theta}`,
      support: { min: 0, start: Math.max(0, mean), step: Math.max(1e-6, sd/2), grow: 1.8, max: mean + 50*sd + 10 }
    };
  }
  if (d==="chisq"){
    const nu = Number(document.getElementById("nu").value);
    if (!(nu > 0)) return {F: null, err: "For Chi-square, ν must be > 0."};
    const mean = nu;
    const sd = Math.sqrt(2*nu);
    return {
      F: (x) => chisqCDF(x, nu),
      eq: `Chi-square CDF = Gamma(α=ν/2, θ=2) with ν=${nu}`,
      support: { min: 0, start: Math.max(0, mean), step: Math.max(1e-6, sd/2), grow: 1.8, max: mean + 50*sd + 10 }
    };
  }
  if (d==="exp"){
    const lambda = Number(document.getElementById("lambda").value);
    if (!(lambda > 0)) return {F: null, err: "For Exponential, λ must be > 0."};
    const mean = 1/lambda;
    const sd = 1/lambda;
    return {
      F: (x) => expCDF(x, lambda),
      eq: `Exponential CDF 1 - e^{-λx} with λ=${lambda}`,
      support: { min: 0, start: mean, step: Math.max(1e-6, sd/2), grow: 1.8, max: mean + 80*sd + 10 }
    };
  }
  return {F: null, err: "Unknown distribution."};
}

/* -----------------------------
   AREA calculations
------------------------------*/
document.getElementById("calcArea").addEventListener("click", () => {
  const d = distEl.value;
  const t = tailAreaEl.value;
  const x = Number(document.getElementById("x").value);
  const a = Number(document.getElementById("a").value);
  const b = Number(document.getElementById("b").value);

  showMessage("", "");

  const c = getCDF(d);
  if (c.err){ showMessage("warn", c.err); return; }
  const F = c.F;

  let prob = NaN;
  let interp = "";
  let eq = "";

  if (t === "lt"){
    const Fx = clamp01(F(x));
    prob = Fx;
    eq = `${c.eq}\nP(X < x) = F(x),  x=${x}`;
    interp = `Area to the LEFT of x=${x}.`;
  } else if (t === "gt"){
    const Fx = clamp01(F(x));
    prob = clamp01(1 - Fx);
    eq = `${c.eq}\nP(X > x) = 1 - F(x),  x=${x}`;
    interp = `Area to the RIGHT of x=${x}.`;
  } else {
    const lo = Math.min(a,b), hi = Math.max(a,b);
    const Flo = clamp01(F(lo));
    const Fhi = clamp01(F(hi));
    prob = clamp01(Fhi - Flo);
    eq = `${c.eq}\nP(a < X < b) = F(b) - F(a)\na=${lo}, b=${hi}`;
    interp = `Area BETWEEN a=${lo} and b=${hi}.`;
  }

  if (!isFinite(prob)){
    showMessage("warn", "Computation failed (check parameters/inputs).");
    return;
  }

  outLabelEl.textContent = "Probability";
  poutEl.textContent = fmt(prob);
  interpEl.textContent = interp;
  eqEl.textContent = eq;
  showMessage("ok", "Computed successfully.");
});

/* -----------------------------
   INVERSE calculations
------------------------------*/
document.getElementById("calcInv").addEventListener("click", () => {
  const d = distEl.value;
  const t = tailInvEl.value;
  const p = Number(document.getElementById("p_in").value);

  showMessage("", "");

  if (!(p >= 0 && p <= 1) || !isFinite(p)){
    showMessage("warn", "p must be a finite number between 0 and 1 (inclusive).");
    return;
  }

  const c = getCDF(d);
  if (c.err){ showMessage("warn", c.err); return; }
  const F = c.F;
  const sup = c.support;

  let interp = "";
  let eq = "";
  let out = "";

  // Convert request to lower-tail targets
  if (t === "lt"){
    const target = p;
    const sol = invertMonotoneCDF(F, target, sup);
    if (sol.err){ showMessage("warn", sol.err); return; }
    outLabelEl.textContent = "Critical value x";
    out = fmt(sol.x);
    interp = `x such that P(X < x) = ${fmt(p)}.`;
    eq = `${c.eq}\nSolve F(x)=p with p=${p}\nResult: x=${sol.x}`;
    if (sol.warn) showMessage("ok", `Computed with warning:\n${sol.warn}`); else showMessage("ok", "Computed successfully.");
  }
  else if (t === "gt"){
    // P(X > x)=p  =>  F(x)=1-p
    const target = 1 - p;
    const sol = invertMonotoneCDF(F, target, sup);
    if (sol.err){ showMessage("warn", sol.err); return; }
    outLabelEl.textContent = "Critical value x";
    out = fmt(sol.x);
    interp = `x such that P(X > x) = ${fmt(p)} (equivalently F(x)=${fmt(1-p)}).`;
    eq = `${c.eq}\nSolve 1 - F(x)=p  ⇒  F(x)=1-p=${1-p}\nResult: x=${sol.x}`;
    if (sol.warn) showMessage("ok", `Computed with warning:\n${sol.warn}`); else showMessage("ok", "Computed successfully.");
  }
  else {
    // central interval: tails (1-p)/2 each, return [L,U]
    const tail = (1 - p)/2;
    const pL = tail;
    const pU = 1 - tail;

    const solL = invertMonotoneCDF(F, pL, sup);
    const solU = invertMonotoneCDF(F, pU, sup);

    if (solL.err){ showMessage("warn", "Lower bound solve failed:\n" + solL.err); return; }
    if (solU.err){ showMessage("warn", "Upper bound solve failed:\n" + solU.err); return; }

    outLabelEl.textContent = "Central interval [L, U]";
    out = `[${fmt(solL.x)}, ${fmt(solU.x)}]`;
    interp = `Central interval with P(L < X < U) = ${fmt(p)} and each tail = ${(1-p)/2}.`;
    eq = `${c.eq}\nCentral interval: L=F^{-1}((1-p)/2), U=F^{-1}(1-(1-p)/2)\n(1-p)/2=${tail}\nL=${solL.x}\nU=${solU.x}`;
    showMessage("ok", "Computed successfully.");
  }

  poutEl.textContent = out;
  interpEl.textContent = interp;
  eqEl.textContent = eq;
});

/* -----------------------------
   Init
------------------------------*/
function init(){
  updateDistVisibility();
  updateAreaTailVisibility();
  updateInvHelp();
  setMode("area");
}
init();
</script>
</body>
</html>
